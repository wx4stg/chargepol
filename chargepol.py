"""
This script defines parameters, have functions and code 
to predict charge layer polarity from flashes.

It uses VHF Lightning Mapping Array Level 2 HDF5 files obtained from lmatools as input. 
Please refer to lmatools to convert LMA Level 1 data to Level 2.

Change parameters in the beggining of the code (lines 29-62) accordingly.

Usage: python chargepol.py

Output: NetCDF file with polarity of a charge layer, time of a charge layer in seconds after 0 UTC, 
charge layer bottom altitude in km, charge layer width in km, east-west distance from network center in km, 
south-north distance from network center in km.

Please refer to Medina et al., 2021, AGU ESS
Or contact bruno.medina@colorado.edu

Created on 04/23/2020
"""

# Import packages:
import numpy as np
import glob
import xarray as xr
from datetime import datetime as dt, timezone
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import argparse
from os import path, remove
from pathlib import Path

parser = argparse.ArgumentParser(description='Cluster VHF source data into flashes and create gridded data products, similar to lmatools flash_sort_and_grid.py\nOutputs to netCDF files, one per 10-minute interval.')
parser.add_argument('-i', '--input', nargs='+', required=True, help='Path or paths to LMA .nc files to process.')
parser.add_argument('--max-range', help='Maximum range in km from network center. Default is 100km', type=float, default=100)
parser.add_argument('--nsou', help='Minimum number of sources for a flash. Default is 20.', type=int, default=20)
parser.add_argument('--min-pb-dur', help='Minimum duration of a preliminary breakdown, in ms. Default is 2ms', type=float, default=2)
parser.add_argument('--max-pb-dur', help='Maximum duration of a preliminary breakdown, in ms. Default is 10ms', type=float, default=10)
parser.add_argument('--min-pb-sou', help='Minimum number of preliminary breakdown sources. Default is 4.', type=int, default=4)
parser.add_argument('--min-ver-speed', help='Minimum preliminary breakdown vertical speed in km/milissecond. Default is 0.05 == 5*10^4 m/s)', type=float, default=.05)
parser.add_argument('--max-mse', help='Maximum MSE for the linear regression fit to the preliminary breakdown sources. Default is 0.25', type=float, default=0.25)
parser.add_argument('--min-perc-interv', help='Lower bound of percentile interval to define charge layers. Specify percentage as decimal. Default is 0.1 == 10%', type=float, default=0.1)
parser.add_argument('--max-perc-interv', help='Upper bound of percentile interval to define charge layers. Specify percentage as decimal. Default is 0.9 == 90%', type=float, default=0.9)
parser.add_argument('--output', help='Path to write output csv.', required=True)
args = parser.parse_args()

def read_lma(file, date_start, max_range, nsou):
    """
    Read LMA level 2 data generated by xlma-python.

    Parameters
    ---------
    file : str
        netcdf4 file to be read.
        Latitude and longitude of network center.
    max_range : float
        Maximum range from the network center to search for flashes, in km.
    nsou : int
        Minimum number of sources for a flash.

    Returns
    -------
    lma_x: 
        West-east distance of sources from network center, in km
    lma_y: 
        South-north distance of sources from network center, in km
    lma_z: 
        Altitude of sources above MSL, in km
    lma_t: 
        Time of sources in seconds after 00 UTC
    lma_flid: 
        Flash ID of sources
    flid: 
        Flash ID of flashes within max_range and with number of sources > nsou 
    flx: 
        West-east distance of flash centroid from network center, in km
    fly:
        South-north distance of flash centroid from network center, in km
    fl_lon: 
        Degrees longitude of flash centroid from network center
    fl_lat:
        Degrees latitude of flash centroid from network center
    date_start:
        UTC timestamp of 0z on the first day of analysis
    """
    print(f"Reading: {file}")
    data = xr.open_dataset(file).sortby('event_time')
    # Extract sources x/y/z
    lma_x = data.event_x.data/1000
    lma_y = data.event_y.data/1000
    lma_z = data.event_altitude.data/1000
    # Recover seconds since 0 UTC from datetime64 objects
    if date_start is None:
        date_start = dt.utcfromtimestamp(data.event_time.data[0].item()/1e9).replace(hour=0, minute=0, second=0, microsecond=0, tzinfo=timezone.utc).timestamp()
    lma_t = (data.event_time.data.astype(float)/1e9 - date_start).astype(float)
    # Extract flash IDs from the sources and the flashes
    lma_flid = data.event_parent_flash_id.data
    flid = data.flash_id.data
    # Get flash centroid x/y
    if 'flash_center_x' in data.variables:
        flx = data.flash_center_x.data/1000
        fly = data.flash_center_y.data/1000
    elif 'flash_ctr_x' in data.variables:
        flx = data.flash_ctr_x.data/1000
        fly = data.flash_ctr_y.data/1000
    elif 'flash_center_longitude' in data.variables:
        Re = 6378137 # m, radius of Earth
        flx = (Re * (np.deg2rad(data.flash_center_longitude.data) - np.deg2rad(data.network_center_longitude.data)) * np.cos(np.deg2rad(data.network_center_latitude.data)))/1000
        fly = (Re * (np.deg2rad(data.flash_center_latitude.data) - np.deg2rad(data.network_center_latitude.data)))/1000
    else:
        raise ValueError('No flash center coordinates found')
    fl_lon = data.flash_center_longitude.data
    fl_lat = data.flash_center_latitude.data
    # Generate mask of flashes too far or not enough points
    fcent_xy = (flx**2 + fly**2)**0.5
    mask = (fcent_xy <= max_range) & (data.flash_event_count.data >= nsou)
    # Return masked values
    return lma_x, lma_y, lma_z, lma_t, lma_flid, flid[mask], flx[mask], fly[mask], fl_lon[mask], fl_lat[mask], date_start


def regression_pb(lma_t_fl, lma_z_fl, min_t, max_pb_dur):

    """
    Linear regression fit to the preliminary breakdown sources.

    Parameters
    ---------
    lma_t_fl : float
        Time of sources in seconds after 00 UTC.
    lma_z_fl : float 
        Altitude of sources above MSL, in km.
    min_t : float
        Time of the first source of a flash in seconds after 00 UTC.
    max_pb_dur : int
        Maximum duration of a preliminary breakdown, in ms.

    Returns
    -------
    ch_hgt_thresh, pb_vert_speed, mse: 
        Linear regression intercept (charge height threshold), in km
    pb_vert_speed: 
        Linear regression coefficient (preliminary breakdown vertical speed), in km/ms
    mse: 
        Regression mean squared error
    """
    
    # PB sources:
    whpb = np.where((1000.*(lma_t_fl-min_t) <= max_pb_dur ) & (lma_z_fl <= 20))
    x = lma_t_fl[whpb] 
    x = 1000.*(x-min_t)
    y = lma_z_fl[whpb]
    x=x.transpose()
    x = x.reshape(x.shape[0], 1)
    x=x.tolist()
    
    # Linear regression:
    model = LinearRegression()
    
    # Minimum number of PB sources and minimum PB duration conditions are applied here:
    if y.size >=min_pb_sou and np.max(x)>min_pb_dur:
        model.fit(x, y)
        y_pred = model.predict(x)       
        # Mean squared error:
        mse = mean_squared_error(y, y_pred)
    else:
        model.coef_ = 0
        model.intercept_ = 0
        mse = 2.0
        
    pb_vert_speed = model.coef_
    ch_hgt_thresh = model.intercept_
    
    return ch_hgt_thresh, pb_vert_speed, mse 

def write_output(filename_output, pos_time, pos_zmin, pos_zwid, pos_flax, pos_flay, pos_fla_lon, pos_fla_lat, neg_time, neg_zmin, neg_zwid, neg_flax, neg_flay, neg_fla_lon, neg_fla_lat):
     
    """
    Write output to a .nc file.

    Parameters
    ---------
    filename_output : str
        File name to write output.
    pos_time : float 
        Positive charge layer time, in seconds after 00 UTC.
    pos_zmin : float
        Positive charge layer bottom height, in km above MSL.
    pos_zwid : float
        Positive charge layer width, in km.
    pos_flax : float
        Positive charge layer west-east distance to network center, in km.
    pos_flay : float
        Positive charge layer south-north distance to network center, in km.
    pos_fla_lon : float
        Positive charge layer longitude degrees.
    pos_fla_lat : float
        Positive charge layer latitude degrees.
    neg_time : float
        Negative charge layer time, in seconds after 00 UTC.
    neg_zmin : float
        Negative charge layer bottom height, in km above MSL.
    neg_zwid : float
        Negative charge layer width, in km.
    neg_flax : float
        Negative charge layer west-east distance to network center, in km.
    neg_flay : float
        Negative charge layer south-north distance to network center, in km.
    neg_fla_lon : float
        Negative charge layer longitude degrees.
    neg_fla_lat : float
        Negative charge layer latitude degrees.

    """
    
    pos_time = np.array(pos_time, np.dtype(float))
    pos_zmin = np.array(pos_zmin, np.dtype(float))
    pos_zwid = np.array(pos_zwid, np.dtype(float))
    pos_flax = np.array(pos_flax, np.dtype(float))
    pos_flay = np.array(pos_flay, np.dtype(float))
    pos_fla_lon = np.array(pos_fla_lon, np.dtype(float))
    pos_fla_lat = np.array(pos_fla_lat, np.dtype(float))
    neg_time = np.array(neg_time, np.dtype(float))
    neg_zmin = np.array(neg_zmin, np.dtype(float))
    neg_zwid = np.array(neg_zwid, np.dtype(float))
    neg_flax = np.array(neg_flax, np.dtype(float))
    neg_flay = np.array(neg_flay, np.dtype(float))
    neg_fla_lon = np.array(neg_fla_lon, np.dtype(float))
    neg_fla_lat = np.array(neg_fla_lat, np.dtype(float))

    e = open(filename_output, 'a')
    e.write("# Generated by ChargePol\n")
    e.write("#charge (pos/neg), time (UT sec), bottom height of layer (km), depth of layer (km), x distance from LMA center (km), y distance from LMA center (km), longitude, latitude\n")
    e.write("charge,time,zmin,zwidth,x,y,lon,lat\n")
    for f in np.arange(0,len(pos_time)):
        e.write("pos,%f,%f,%f,%f,%f,%f,%f\n" % (pos_time[f], pos_zmin[f], pos_zwid[f], pos_flax[f], pos_flay[f], pos_fla_lon[f], pos_fla_lat[f]))

    for g in np.arange(0,len(neg_time)):
        e.write("neg,%f,%f,%f,%f,%f,%f,%f\n" % (neg_time[g], neg_zmin[g], neg_zwid[g], neg_flax[g], neg_flay[g], neg_fla_lon[g], neg_fla_lat[g]))
        
    e.close()

if __name__ == '__main__':
    filenames = sorted(args.input)
    if len(filenames) == 1:
        filenames = sorted(glob.glob(filenames[0]))
    nsou = args.nsou
    min_pb_dur = args.min_pb_dur
    max_pb_dur = args.max_pb_dur
    min_pb_sou = args.min_pb_sou
    min_ver_speed = args.min_ver_speed
    max_mse = args.max_mse
    perc_interv = np.array([args.min_perc_interv, args.max_perc_interv])
    filename_output = args.output


    # Define variables:
    pos_zmin = []
    pos_zwid = []
    pos_time = []
    pos_flax = []
    pos_flay = []
    pos_fla_lon = []
    pos_fla_lat = []
    neg_zmin = []
    neg_zwid = []
    neg_time = []
    neg_flax = []
    neg_flay = []
    neg_fla_lon = []
    neg_fla_lat = []

    date_start = None
    # Loop on each LMA level 2 .h5 file
    for i in range(0,len(filenames)): 

        file = filenames[i]
        
        # Read LMA data:    
        lma_x, lma_y, lma_z, lma_t, lma_flid, flid, flx, fly, fl_lon, fl_lat, date_start = read_lma(file, date_start, max_range, nsou)

        # Loop for each flash:    
        for j in range(0,flid.size):
        
            # LMA flash ID:
            flashid = flid[j] 
        
            # Sources associated to a flash ID:
            ind = np.where(lma_flid==flashid)
            lma_x_fl = lma_x[ind]
            lma_y_fl = lma_y[ind]
            lma_z_fl = lma_z[ind]
            lma_t_fl = lma_t[ind]
            lma_flid_fl = lma_flid[ind]
            
            # Time of first source of a flash:
            min_t = np.min(lma_t_fl)

            # Calculate linear regression on PB sources:
            ch_hgt_thresh, pb_vert_speed, mse = regression_pb(lma_t_fl, lma_z_fl, min_t, max_pb_dur)
                    
            # Non-PB sources sources (after 10 ms):
            whch = np.where((1000.*(lma_t_fl-min_t) > max_pb_dur ) & (lma_z_fl <= 20))
            zch = lma_z_fl[whch]
            tch = lma_t_fl[whch]
                    
            # If flash passes vertical speed and MSE conditions:
            if np.abs(pb_vert_speed) > min_ver_speed and mse < max_mse:
            
                # Non-PB sources above and below charge height threshold (CHT):
                wh_uplay = np.where(zch >= ch_hgt_thresh)
                wh_lwlay = np.where(zch < ch_hgt_thresh)
                    
                # Upward PB:
                if np.sign(pb_vert_speed) > 0:
                    
                    # Positive layer above CHT, negative below CHT
                    pos_sour = zch[wh_uplay]
                    neg_sour = zch[wh_lwlay]
                    pos_t = tch[wh_uplay]
                    neg_t = tch[wh_lwlay]
                    
                    # If candidate sources for positive layer are found:                
                    if pos_sour.size > 0:
                
                        # Get sources that define positive charge layer, percentile interval on altitudes
                        pos_qua = np.quantile(pos_sour, [perc_interv[0], perc_interv[1]]) 
                        whqua = np.where((pos_sour > pos_qua[0]) & (pos_sour < pos_qua[1] ))
                        pos_sour = pos_sour[whqua] 
                        pos_t = pos_t[whqua] 
                        if pos_sour.size > 0:
                            pos_zmin.append([np.min(pos_sour)])
                            pos_zwid.append([np.max(pos_sour)-np.min(pos_sour)])
                            pos_time.append([np.min(pos_t)])
                            pos_flax.append([flx[j]])
                            pos_flay.append([fly[j]])
                            pos_fla_lon.append([fl_lon[j]])
                            pos_fla_lat.append([fl_lat[j]])
                        
                    # If candidate sources for negative layer are found: 
                    if neg_sour.size > 0:                
                                
                        # Get sources that define negative charge layer, percentile interval on altitudes:
                        neg_qua = np.quantile(neg_sour, [perc_interv[0], perc_interv[1]]) 
                        wnqua = np.where((neg_sour > neg_qua[0]) & (neg_sour < neg_qua[1] ))
                        neg_sour = neg_sour[wnqua] 
                        neg_t = neg_t[wnqua] 
                        if neg_sour.size > 0:
                            neg_zmin.append([np.min(neg_sour)])
                            neg_zwid.append([np.max(neg_sour)-np.min(neg_sour)])
                            neg_time.append([np.min(neg_t)])
                            neg_flax.append([flx[j]])
                            neg_flay.append([fly[j]])
                            neg_fla_lon.append([fl_lon[j]])
                            neg_fla_lat.append([fl_lat[j]])
                    
                # Downward PB:
                else:
                
                    # Negative layer above CHT, positive below CHT:
                    pos_sour = zch[wh_lwlay]
                    neg_sour = zch[wh_uplay]
                    pos_t = tch[wh_lwlay]
                    neg_t = tch[wh_uplay]
                    
                    # If candidate sources for positive layer are found:  
                    if pos_sour.size > 0:
                
                        # Get sources that define positive charge layer, percentile interval on altitudes:
                        pos_qua = np.quantile(pos_sour, [perc_interv[0], perc_interv[1]]) 
                        whqua = np.where((pos_sour > pos_qua[0]) & (pos_sour < pos_qua[1] ))
                        pos_sour = pos_sour[whqua] 
                        pos_t = pos_t[whqua] 
                        if pos_sour.size > 0:
                            pos_zmin.append([np.min(pos_sour)])
                            pos_zwid.append([np.max(pos_sour)-np.min(pos_sour)])
                            pos_time.append([np.min(pos_t)])
                            pos_flax.append([flx[j]])
                            pos_flay.append([fly[j]])
                            pos_fla_lon.append([fl_lon[j]])
                            pos_fla_lat.append([fl_lat[j]])
                    
                    # If candidate sources for negative layer are found:                 
                    if neg_sour.size > 0:
                                    
                        # Get sources that define negative charge layer, percentile interval on altitudes:
                        neg_qua = np.quantile(neg_sour, [perc_interv[0], perc_interv[1]]) 
                        wnqua = np.where((neg_sour > neg_qua[0]) & (neg_sour < neg_qua[1] ))
                        neg_sour = neg_sour[wnqua] 
                        neg_t = neg_t[wnqua] 
                        if neg_sour.size > 0:
                            neg_zmin.append([np.min(neg_sour)])
                            neg_zwid.append([np.max(neg_sour)-np.min(neg_sour)])
                            neg_time.append([np.min(neg_t)])
                            neg_flax.append([flx[j]])
                            neg_flay.append([fly[j]])
                            neg_fla_lon.append([fl_lon[j]])
                            neg_fla_lat.append([fl_lat[j]])
                        
    # Save charge layers output:
    if path.exists(filename_output):
        remove(filename_output)
    Path(path.dirname(filename_output)).mkdir(parents=True, exist_ok=True)
    write_out = write_output(filename_output, pos_time, pos_zmin, pos_zwid, pos_flax, pos_flay, pos_fla_lon, pos_fla_lat, neg_time, neg_zmin, neg_zwid, neg_flax, neg_flay, neg_fla_lon, neg_fla_lat)

    print('Done')
